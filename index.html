<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Princess Arcade â€” All Games</title>
<style>
  :root{--accent:#ff4081;--bg:#fff6fb;--card:#fff;--muted:#3b2b3b}
  html,body{height:100%;margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,Arial;background:var(--bg);-webkit-font-smoothing:antialiased}
  .wrap{max-width:1100px;margin:12px auto;padding:14px}
  header{display:flex;justify-content:space-between;align-items:center}
  h1{margin:0;color:var(--muted)}
  nav{margin:12px 0;display:flex;gap:8px;flex-wrap:wrap}
  .tab{padding:8px 12px;border-radius:9px;border:none;background:var(--card);cursor:pointer;box-shadow:0 8px 20px rgba(0,0,0,0.04)}
  .tab.active{background:linear-gradient(180deg,var(--accent),#e6176f);color:#fff}
  .layout{display:flex;gap:14px}
  .left{flex:1}
  .right{width:320px}
  .panel{background:var(--card);padding:12px;border-radius:12px;box-shadow:0 10px 30px rgba(0,0,0,0.06)}
  canvas{width:100%;height:520px;border-radius:10px;background:#fff;display:block}
  #drawCanvas{height:520px}
  .controls{display:flex;gap:8px;align-items:center;margin-top:10px}
  .btn{padding:8px 12px;border-radius:10px;border:none;background:var(--accent);color:#fff;cursor:pointer}
  .btn.ghost{background:#fff;border:1px solid #eee;color:var(--muted)}
  .small{font-size:13px;color:#6b4a62}
  /* modals */
  .modalMask{position:fixed;inset:0;background:rgba(0,0,0,0.5);display:none;align-items:center;justify-content:center;z-index:999}
  .modal{background:#fff;width:92%;max-width:720px;border-radius:12px;padding:16px;max-height:84vh;overflow:auto}
  .prin-grid{display:flex;flex-wrap:wrap;gap:10px}
  .prin{flex:0 0 48%;padding:10px;border-radius:10px;background:#fff5fb;border:2px solid transparent;cursor:pointer}
  .prin.sel{border-color:var(--accent);box-shadow:0 12px 28px rgba(255,64,129,0.08)}
  .match-grid{display:flex;flex-wrap:wrap;gap:10px;justify-content:center;padding-top:8px}
  .card{width:100px;height:120px;border-radius:10px;background:#fff;display:flex;align-items:center;justify-content:center;font-size:30px;cursor:pointer;border:2px solid #fde6f2}
  #notify{position:fixed;left:50%;top:16px;transform:translateX(-50%);background:#fff;padding:8px 12px;border-radius:10px;box-shadow:0 12px 30px rgba(0,0,0,0.12);display:none;z-index:1100}
  footer{margin-top:12px;color:#806070;font-size:13px}
  @media (max-width:900px){ .prin{flex:0 0 100% } .right{width:100%} canvas{height:420px} #drawCanvas{height:420px} }
</style>
</head>
<body>
<div class="wrap">
  <header>
    <div>
      <h1>Princess Arcade</h1>
      <div class="small">Pick a princess, play 4 games, earn coins & buy hearts. Built to work.</div>
    </div>
    <div style="display:flex;gap:10px;align-items:center">
      <div class="small" style="background:#fff;padding:8px;border-radius:10px;box-shadow:0 8px 20px rgba(0,0,0,0.04)">Coins: <strong id="coins">0</strong></div>
      <div class="small" style="background:#fff;padding:8px;border-radius:10px;box-shadow:0 8px 20px rgba(0,0,0,0.04)">Hearts: <strong id="hearts">0</strong></div>
      <button id="openStore" class="btn">Store</button>
      <button id="openInstr" class="btn btn.ghost">Instructions</button>
    </div>
  </header>

  <nav id="tabs">
    <button class="tab active" data-game="flap">Flappy Princess</button>
    <button class="tab" data-game="runner">Princess Runner</button>
    <button class="tab" data-game="match">Match Game</button>
    <button class="tab" data-game="path">Draw-a-Path</button>
    <button class="tab" data-game="choose">Choose Princess</button>
  </nav>

  <div class="layout">
    <div class="left">
      <div class="panel" id="gamePanel">
        <canvas id="mainCanvas"></canvas>
        <canvas id="drawCanvas" style="display:none"></canvas>
        <div id="matchBoard" style="display:none"></div>
      </div>

      <div class="controls">
        <div id="selectedInfo" class="small">No princess selected</div>
        <div style="flex:1"></div>
        <div id="countdown" class="small"></div>
        <button id="startBtn" class="btn">Start</button>
        <button id="resetBtn" class="btn btn.ghost">Reset</button>
      </div>
    </div>

    <div class="right">
      <div class="panel">
        <h3 style="margin:6px 0">Object Control</h3>
        <div class="small">Tap the button or press <strong>SPACE</strong> during Flappy/Runner.</div>
        <div style="height:8px"></div>
        <div id="objectArea"></div>
        <hr style="margin:10px 0">
        <div class="small">Shop: buy hearts (30 coins each). Hearts let you survive one hit.</div>
        <div style="height:8px"></div>
        <button id="chooseBtn" class="btn btn.ghost">Choose/Change Princess</button>
      </div>
    </div>
  </div>

  <footer>Built to work â€” tell me any tweak and Iâ€™ll adjust it.</footer>
</div>

<!-- Princess picker modal -->
<div id="selectModal" class="modalMask" style="display:flex">
  <div class="modal">
    <h2>Choose your Princess</h2>
    <p class="small">Pick a princess â€” each has an object youâ€™ll use to dodge.</p>
    <div class="prin-grid" id="prinGrid"></div>
    <div style="text-align:right;margin-top:10px">
      <button id="confirmPrincess" class="btn">Confirm</button>
    </div>
  </div>
</div>

<!-- Store modal -->
<div id="shopModal" class="modalMask"><div class="modal">
  <h3>Shop</h3>
  <p class="small">Hearts cost <strong>30</strong> coins. Hearts save you from a full reset.</p>
  <div style="text-align:right"><button id="buyHeart" class="btn">Buy Heart (30)</button> <button id="closeShop" class="btn btn.ghost">Close</button></div>
</div></div>

<!-- Instructions modal -->
<div id="instrModal" class="modalMask"><div class="modal">
  <h3>Instructions</h3>
  <p class="small" style="line-height:1.5">
    <strong>Flappy Princess</strong> â€” press SPACE or tap the object button to dash/up-flap. Avoid obstacles (they show the same object). Hitting an obstacle uses a heart or resets you to start; passing obstacles gives coins.<br><br>
    <strong>Princess Runner</strong> â€” Start triggers a 3â€“2â€“1 countdown. Click/SPACE to jump. Avoid obstacles. Coins on the track give coins.<br><br>
    <strong>Match Game</strong> â€” 12 cards (6 pairs). Flip two â€” matched pairs disappear and award coins. Clear the board to get bonus coins.<br><br>
    <strong>Draw-a-Path</strong> â€” Draw ahead of the moving world. The princess-car follows the drawn path. The world scrolls and new obstacles spawn; avoid them to collect coins.
  </p>
  <div style="text-align:right"><button id="closeInstrModal" class="btn btn.ghost">Close</button></div>
</div></div>

<div id="notify" class="notify"></div>

<script>
/* ***********************************************
   Princess Arcade â€” functional, all-in-one file
   - Four games: Flappy, Runner, Match, Draw Path
   - Princess selection, Store, Instructions
   - Coins & hearts persist in localStorage
   - Fast, robust controls: Space + touch/mouse
   *********************************************** */

// ---------- Persistence & HUD ----------
let coins = Number(localStorage.getItem('pa_coins') || 0);
let hearts = Number(localStorage.getItem('pa_hearts') || 0);
const coinsEl = document.getElementById('coins'), heartsEl = document.getElementById('hearts');
function saveState(){ localStorage.setItem('pa_coins', coins); localStorage.setItem('pa_hearts', hearts); updateHUD(); }
function updateHUD(){ coinsEl.textContent = coins; heartsEl.textContent = hearts; }
updateHUD();

function notify(msg, time=1500){
  const n = document.getElementById('notify');
  n.textContent = msg; n.style.display='block';
  clearTimeout(n._t); n._t = setTimeout(()=> n.style.display='none', time);
}

// ---------- Princess list ----------
const PRINCESSES = [
  {name:'Ariel', object:'seashell', emoji:'ðŸš', color:'#ff7fbf'},
  {name:'Elsa', object:'snowflake', emoji:'â„ï¸', color:'#cfe7ff'},
  {name:'Moana', object:'wave', emoji:'ðŸŒŠ', color:'#9fd4ff'},
  {name:'Mulan', object:'sword', emoji:'ðŸ—¡ï¸', color:'#ffd6e9'},
  {name:'Cinderella', object:'slipper', emoji:'ðŸ‘ ', color:'#cfe0ff'},
  {name:'Rapunzel', object:'lizard', emoji:'ðŸ¦Ž', color:'#f7d06a'},
  {name:'Tiana', object:'frog', emoji:'ðŸ¸', color:'#9be9b6'},
  {name:'Belle', object:'book', emoji:'ðŸ“–', color:'#ffd07a'}
];
let selected = null;

// populate picker grid
const prinGrid = document.getElementById('prinGrid');
PRINCESSES.forEach((p, i) => {
  const el = document.createElement('div');
  el.className = 'prin';
  el.innerHTML = `<div style="font-weight:700">${p.name}</div><div class="small">object: ${p.object} ${p.emoji}</div>`;
  el.addEventListener('click', ()=> {
    document.querySelectorAll('.prin').forEach(x=>x.classList.remove('sel'));
    el.classList.add('sel');
    el.dataset.idx = i;
  });
  prinGrid.appendChild(el);
});

// show select modal on load
const selectModal = document.getElementById('selectModal');
selectModal.style.display = 'flex';
document.getElementById('confirmPrincess').addEventListener('click', ()=>{
  const chosen = document.querySelector('.prin.sel');
  if(!chosen){ notify('Please pick a princess'); return; }
  const idx = Array.from(prinGrid.children).indexOf(chosen);
  selected = PRINCESSES[idx];
  selectModal.style.display = 'none';
  document.getElementById('selectedInfo').textContent = `${selected.name} â€” ${selected.object} ${selected.emoji}`;
  setupObjectButton();
  notify(`${selected.name} selected`);
});

// also show modal on choose/change click
document.getElementById('chooseBtn').addEventListener('click', ()=> { selectModal.style.display='flex'; });

// ---------- Modals: Store & Instructions ----------
document.getElementById('openStore').addEventListener('click', ()=> document.getElementById('shopModal').style.display = 'flex');
document.getElementById('closeShop').addEventListener('click', ()=> document.getElementById('shopModal').style.display = 'none');
document.getElementById('openInstr').addEventListener('click', ()=> document.getElementById('instrModal').style.display = 'flex');
document.getElementById('closeInstrModal').addEventListener('click', ()=> document.getElementById('instrModal').style.display = 'none');
document.getElementById('buyHeart').addEventListener('click', ()=> {
  if(coins >= 30){ coins -= 30; hearts++; saveState(); notify('Heart purchased'); } else notify('Need 30 coins');
});

// ---------- Tabs & game switching ----------
let currentGame = 'flap';
const tabs = document.querySelectorAll('.tab');
tabs.forEach(t => t.addEventListener('click', ()=> {
  tabs.forEach(x=>x.classList.remove('active'));
  t.classList.add('active');
  currentGame = t.dataset.game;
  showGameView(currentGame);
}));

function showGameView(game){
  // hide canvases / match board
  document.getElementById('mainCanvas').style.display = 'none';
  document.getElementById('drawCanvas').style.display = 'none';
  document.getElementById('matchBoard').style.display = 'none';
  // stop any running loops
  stopAllGames();
  document.getElementById('countdown').textContent = '';
  if(game === 'flap'){ document.getElementById('mainCanvas').style.display = 'block'; initFlap(); drawFlapOnce(); }
  if(game === 'runner'){ document.getElementById('mainCanvas').style.display = 'block'; initRunner(); drawRunnerOnce(); }
  if(game === 'match'){ document.getElementById('matchBoard').style.display = 'flex'; initMatch(); }
  if(game === 'path'){ document.getElementById('drawCanvas').style.display = 'block'; initPath(); drawPathOnce(); }
  if(game === 'choose'){ selectModal.style.display = 'flex'; }
}
showGameView('flap'); // default

// ---------- Canvas setup ----------
const mainCanvas = document.getElementById('mainCanvas');
const ctx = mainCanvas.getContext('2d');
const drawCanvas = document.getElementById('drawCanvas');
const dctx = drawCanvas.getContext('2d');
function fitCanvases(){
  const panel = document.getElementById('gamePanel');
  const r = panel.getBoundingClientRect();
  mainCanvas.width = Math.max(560, Math.floor(r.width));
  mainCanvas.height = Math.max(420, Math.floor(r.height - 40));
  drawCanvas.width = mainCanvas.width;
  drawCanvas.height = Math.max(440, mainCanvas.height + 40);
}
window.addEventListener('resize', ()=> { fitCanvases(); drawCurrentView(); });
fitCanvases();

// ---------- Game management ----------
let rafHandle = null;
function stopAllGames(){ if(rafHandle) cancelAnimationFrame(rafHandle); rafHandle = null; // also stop intervals if any
  if(flapInterval) clearInterval(flapInterval);
  if(runnerInterval) clearInterval(runnerInterval);
  if(pathInterval) clearInterval(pathInterval);
}
function drawCurrentView(){
  if(currentGame === 'flap') drawFlapOnce();
  if(currentGame === 'runner') drawRunnerOnce();
  if(currentGame === 'match') renderMatch();
  if(currentGame === 'path') drawPathOnce();
}

// ---------- Object control button ----------
function setupObjectButton(){
  const area = document.getElementById('objectArea');
  area.innerHTML = '';
  if(!selected) return;
  const btn = document.createElement('button');
  btn.className = 'btn';
  btn.textContent = `${selected.object} ${selected.emoji}`;
  btn.addEventListener('click', ()=> {
    if(currentGame === 'flap' && flapState.running) doFlapDash();
    if(currentGame === 'runner' && runnerState.running) triggerRunnerJump();
    // draw-path: no action button
  });
  area.appendChild(btn);
}

// ---------- Start / Reset ----------
document.getElementById('startBtn').addEventListener('click', startWithCountdown);
document.getElementById('resetBtn').addEventListener('click', ()=> { stopAllGames(); showGameView(currentGame); notify('Reset'); });

function startWithCountdown(){
  if(!selected){ notify('Pick a princess first'); selectModal.style.display='flex'; return; }
  let n = 3;
  document.getElementById('countdown').textContent = n;
  const cd = setInterval(()=> {
    n--; document.getElementById('countdown').textContent = n>0 ? n : '';
    if(n < 0){ clearInterval(cd); document.getElementById('countdown').textContent=''; actuallyStart(); }
  }, 700);
}
function actuallyStart(){
  if(currentGame === 'flap'){ flapState.running = true; flapLoop(); notify('Flappy started'); }
  if(currentGame === 'runner'){ runnerState.running = true; runnerLoop(); notify('Runner started'); }
  if(currentGame === 'match'){ notify('Match ready'); }
  if(currentGame === 'path'){ pathState.running = true; pathLoop(); notify('Draw path: draw ahead'); }
}

// ------------------ GAME 1: FLAPPY PRINCESS ------------------
let flapState = null;
let flapInterval = null; // fallback interval for spawning
function initFlap(){
  flapState = {
    running:false,
    princess:{x: Math.floor(mainCanvas.width*0.15), y: Math.floor(mainCanvas.height/2), vy:0, r:28},
    gravity:0.9, flapPower:-10, dashPower:-16,
    obstacles:[], frames:0, score:0, spawnBase:100
  };
}
initFlap();

function drawFlapOnce(){
  ctx.clearRect(0,0,mainCanvas.width, mainCanvas.height);
  ctx.fillStyle = '#fff8fb'; ctx.fillRect(0,0,mainCanvas.width, mainCanvas.height);
  // ground
  ctx.fillStyle = '#fff'; ctx.fillRect(0, mainCanvas.height-60, mainCanvas.width, 60);
  // princess
  const p = flapState.princess;
  ctx.fillStyle = selected ? selected.color : '#ccc';
  ctx.beginPath(); ctx.arc(p.x, p.y, p.r, 0, Math.PI*2); ctx.fill();
  ctx.fillStyle = '#fff'; ctx.font='14px sans-serif'; ctx.textAlign='center'; ctx.fillText(selected ? selected.name.slice(0,2).toUpperCase() : 'PR', p.x, p.y+5);
  // obstacles
  ctx.font='28px serif'; ctx.textAlign='center'; ctx.textBaseline='middle';
  flapState.obstacles.forEach(o => { ctx.fillStyle='#6b2b4b'; ctx.fillText(selected ? selected.emoji : 'â˜…', o.x, o.y); });
  // hud
  ctx.fillStyle = '#333'; ctx.font='14px sans-serif'; ctx.textAlign='left'; ctx.fillText(`Score: ${flapState.score}`, 12, 18);
}

function spawnFlapObstacle(){
  const y = 50 + Math.random()*(mainCanvas.height - 140);
  flapState.obstacles.push({x: mainCanvas.width + 40, y: y, w:36, h:36});
}

function flappyPhysics(){
  flapState.frames++;
  // spawn
  const rate = Math.max(45, flapState.spawnBase - Math.floor(flapState.score/6));
  if(flapState.frames % rate === 0) spawnFlapObstacle();
  // physics
  const p = flapState.princess;
  p.vy += flapState.gravity * 0.6;
  p.y += p.vy;
  if(p.y > mainCanvas.height - 60) { p.y = mainCanvas.height - 60; p.vy = 0; }
  if(p.y < p.r) { p.y = p.r; p.vy = 0; }
  // move obstacles
  for(let i=flapState.obstacles.length-1;i>=0;i--){
    const o = flapState.obstacles[i];
    o.x -= 3 + Math.min(4, flapState.score/80);
    if(o.x + o.w < -20){ flapState.obstacles.splice(i,1); flapState.score++; coins++; saveState(); updateHUD(); }
  }
  // collision
  const px = p.x - p.r*0.5, py = p.y - p.r*0.5, pw = p.r, ph = p.r;
  for(const o of flapState.obstacles){
    const ox = o.x - 18, oy = o.y - 18, ow = o.w, oh = o.h;
    if(px < ox + ow && px + pw > ox && py < oy + oh && py + ph > oy){
      if(hearts > 0){ hearts--; saveState(); p.y = Math.floor(mainCanvas.height/2); flapState.obstacles = []; notify('Heart used â€” returned to start'); return; }
      // keep-5 rule
      if(coins >= 15) coins = 5; else coins = 0;
      saveState(); updateHUD();
      flapState.running = false;
      p.y = Math.floor(mainCanvas.height/2);
      flapState.obstacles = [];
      notify('Hit â€” back to start');
      return;
    }
  }
}

function flapLoop(){
  if(!flapState.running) return;
  flappyPhysics();
  drawFlapOnce();
  rafHandle = requestAnimationFrame(flapLoop);
}

// controls for flap
function doFlapDash(){ if(!flapState) return; flapState.princess.vy = flapState.dashPower || -16; }
window.addEventListener('keydown', (e)=> {
  if(e.code === 'Space'){
    if(currentGame === 'flap' && flapState && flapState.running){ flapState.princess.vy = flapState.flapPower; e.preventDefault(); }
    if(currentGame === 'runner' && runnerState && runnerState.running){ triggerRunnerJump(); e.preventDefault(); }
  }
});
mainCanvas.addEventListener('pointerdown', (e)=> { if(currentGame === 'flap' && flapState && flapState.running) flapState.princess.vy = flapState.flapPower; });

// ---------- GAME 2: RUNNER ----------
let runnerState = null;
let runnerInterval = null;
function initRunner(){
  runnerState = {
    running:false,
    player:{x:80,y: mainCanvas.height - 86, vy:0, w:36, h:36},
    gravity:0.9, jump:-14,
    obstacles:[], frames:0, score:0, spawnRate:110, coinsOnTrack:[]
  };
}
initRunner();

function spawnRunnerObstacle(){ runnerState.obstacles.push({x: mainCanvas.width + 40, y: mainCanvas.height - 86 - 6, w:36, h:36}); }
function spawnRunnerCoin(){ runnerState.coinsOnTrack.push({x: mainCanvas.width + 60, y: mainCanvas.height - 86 - 60, r:8}); }

function runnerUpdate(){
  if(!runnerState.running) return;
  runnerState.frames++;
  if(runnerState.frames % runnerState.spawnRate === 0) spawnRunnerObstacle();
  if(runnerState.frames % 160 === 0) spawnRunnerCoin();
  // physics
  runnerState.player.vy += runnerState.gravity;
  runnerState.player.y += runnerState.player.vy;
  if(runnerState.player.y > mainCanvas.height - 86) { runnerState.player.y = mainCanvas.height - 86; runnerState.player.vy = 0; }
  // move obstacles
  for(let i=runnerState.obstacles.length-1;i>=0;i--){
    const o = runnerState.obstacles[i]; o.x -= 4 + Math.min(3, runnerState.score/100);
    if(o.x + o.w < -20){ runnerState.obstacles.splice(i,1); runnerState.score++; coins++; saveState(); updateHUD(); }
  }
  for(let i=runnerState.coinsOnTrack.length-1;i>=0;i--){
    const c = runnerState.coinsOnTrack[i]; c.x -= 3; const dx = c.x - (runnerState.player.x + runnerState.player.w/2); const dy = c.y - (runnerState.player.y + runnerState.player.h/2);
    if(Math.hypot(dx,dy) < 22){ runnerState.coinsOnTrack.splice(i,1); coins++; saveState(); updateHUD(); notify('+1 coin'); }
    if(c.x < -20) runnerState.coinsOnTrack.splice(i,1);
  }
  // collision
  const px = runnerState.player.x + runnerState.player.w*0.15, py = runnerState.player.y + runnerState.player.h*0.08, pw = runnerState.player.w*0.7, ph = runnerState.player.h*0.84;
  for(const o of runnerState.obstacles){
    if(px < o.x + o.w && px + pw > o.x && py < o.y + o.h && py + ph > o.y){
      if(hearts > 0){ hearts--; saveState(); runnerState.obstacles=[]; runnerState.player.y = mainCanvas.height - 86; notify('Heart used'); return; }
      if(coins >= 15) coins = 5; else coins = 0; saveState(); updateHUD();
      runnerState.running = false; runnerState.obstacles = []; runnerState.player.y = mainCanvas.height - 86; notify('Hit â€” back to start'); return;
    }
  }
}

function drawRunnerOnce(){
  ctx.clearRect(0,0,mainCanvas.width, mainCanvas.height);
  ctx.fillStyle = '#fff8fb'; ctx.fillRect(0,0,mainCanvas.width, mainCanvas.height);
  ctx.fillStyle = '#fff'; ctx.fillRect(0, mainCanvas.height - 86, mainCanvas.width, 86);
  // player
  const p = runnerState.player;
  ctx.fillStyle = selected ? selected.color : '#ccc';
  ctx.beginPath(); ctx.arc(p.x + p.w/2, p.y + p.h/2, p.w/2, 0, Math.PI*2); ctx.fill();
  ctx.fillStyle='#fff'; ctx.font='12px sans-serif'; ctx.textAlign='center'; ctx.fillText(selected ? selected.name.slice(0,2).toUpperCase() : 'PR', p.x + p.w/2, p.y + p.h/2 + 4);
  // obstacles
  ctx.fillStyle = '#7a1b5a'; runnerState.obstacles.forEach(o => ctx.fillRect(o.x, o.y, o.w, o.h));
  // coins
  ctx.fillStyle = '#ffd34d'; runnerState.coinsOnTrack.forEach(c =>{ ctx.beginPath(); ctx.arc(c.x,c.y,c.r,0,Math.PI*2); ctx.fill(); });
  ctx.fillStyle='#333'; ctx.font='14px sans-serif'; ctx.textAlign='left'; ctx.fillText(`Distance: ${runnerState.score}`, 12, 18);
}

function runnerLoop(){
  if(!runnerState.running) return;
  runnerUpdate(); drawRunnerOnce();
  rafHandle = requestAnimationFrame(runnerLoop);
}

function triggerRunnerJump(){ if(!runnerState) return; if(runnerState.player.y >= mainCanvas.height - 86) runnerState.player.vy = runnerState.jump; }
mainCanvas.addEventListener('pointerdown', (e)=>{ if(currentGame === 'runner' && runnerState && runnerState.running) triggerRunnerJump(); });

// ---------- GAME 3: MATCH ----------
let matchState = null;
function initMatch(){
  matchBoard.style.display = 'flex';
  const matchBoardDiv = document.getElementById('matchBoard');
  matchBoardDiv.innerHTML = '';
  const objs = PRINCESSES.map(p=>p.emoji).slice(0,6);
  let deck = objs.concat(objs);
  // shuffle
  for(let i=0;i<300;i++){ const a=Math.floor(Math.random()*deck.length), b=Math.floor(Math.random()*deck.length); [deck[a],deck[b]]=[deck[b],deck[a]]; }
  matchState = {cards: deck.map((o,i)=>({id:i,obj:o,face:false,dead:false})), flipped:[], removed:0};
  renderMatch();
}
function renderMatch(){
  const matchBoardDiv = document.getElementById('matchBoard');
  matchBoardDiv.innerHTML = '';
  matchState.cards.forEach((c,i)=>{
    const el = document.createElement('div'); el.className='card';
    if(c.dead){ el.style.visibility='hidden'; } else if(c.face){ el.textContent = c.obj; } else { el.textContent = '?'; }
    el.addEventListener('click', ()=> flipCard(i));
    matchBoardDiv.appendChild(el);
  });
}
function flipCard(i){
  const card = matchState.cards[i];
  if(card.dead || card.face) return;
  card.face = true; matchState.flipped.push(card); renderMatch();
  if(matchState.flipped.length === 2){
    const [a,b] = matchState.flipped;
    if(a.obj === b.obj){
      a.dead = true; b.dead = true; matchState.removed += 2; coins += 3; saveState(); updateHUD(); notify('+3 coins'); matchState.flipped = []; renderMatch();
      if(matchState.removed === matchState.cards.length){ coins += 10; saveState(); updateHUD(); notify('All pairs cleared! +10 coins'); }
    } else {
      setTimeout(()=>{ a.face=false; b.face=false; matchState.flipped = []; renderMatch(); }, 700);
    }
  }
}

// ---------- GAME 4: DRAW-A-PATH (endless) ----------
let pathState = null;
let pathInterval = null;
function initPath(){
  pathState = {
    running:false,
    points:[], // world coordinates
    car:{x:120,y: drawCanvas.height/2, r:14},
    worldOffset:0,
    obstacles:[], spawnTick:0, speed:2
  };
  // initial obstacles
  for(let i=0;i<6;i++){
    pathState.obstacles.push({x: 600 + i*300 + Math.random()*160, y: 80 + Math.random()*(drawCanvas.height - 160), w:40 + Math.random()*60, h:30 + Math.random()*40});
  }
}
initPath();

function worldToScreen(p){ return {x: p.x - pathState.worldOffset, y: p.y}; }
function drawPathOnce(){
  dctx.clearRect(0,0,drawCanvas.width, drawCanvas.height);
  dctx.fillStyle = '#fff7ff'; dctx.fillRect(0,0,drawCanvas.width, drawCanvas.height);
  // path line
  if(pathState.points.length > 1){
    dctx.strokeStyle = '#ff9ab2'; dctx.lineWidth = 6; dctx.beginPath();
    const p0 = worldToScreen(pathState.points[0]); dctx.moveTo(p0.x, p0.y);
    for(let i=1;i<pathState.points.length;i++){ const p = worldToScreen(pathState.points[i]); dctx.lineTo(p.x,p.y); }
    dctx.stroke();
  }
  // obstacles
  dctx.fillStyle = '#7a1b5a';
  pathState.obstacles.forEach(ob => {
    const sx = ob.x - pathState.worldOffset;
    dctx.fillRect(sx, ob.y, ob.w, ob.h);
  });
  // car
  dctx.fillStyle = selected ? selected.color : '#ccc';
  dctx.beginPath(); dctx.arc(pathState.car.x, pathState.car.y, pathState.car.r, 0, Math.PI*2); dctx.fill();
  dctx.fillStyle='#fff'; dctx.font='12px sans-serif'; dctx.textAlign='center'; dctx.textBaseline='middle';
  dctx.fillText(selected ? selected.name.slice(0,2).toUpperCase() : 'PR', pathState.car.x, pathState.car.y);
}

drawCanvas.addEventListener('pointerdown', (e)=> {
  if(currentGame !== 'path') return;
  const rect = drawCanvas.getBoundingClientRect();
  const x = (e.clientX - rect.left) * (drawCanvas.width / rect.width) + pathState.worldOffset;
  const y = (e.clientY - rect.top) * (drawCanvas.height / rect.height);
  pathState.points.push({x,y});
});
drawCanvas.addEventListener('pointermove', (e)=> {
  if(currentGame !== 'path' || !(e.buttons || e.touches)) return;
  const rect = drawCanvas.getBoundingClientRect();
  const x = (e.clientX - rect.left) * (drawCanvas.width / rect.width) + pathState.worldOffset;
  const y = (e.clientY - rect.top) * (drawCanvas.height / rect.height);
  pathState.points.push({x,y});
  if(pathState.points.length > 1000) pathState.points.shift();
  drawPathOnce();
});
drawCanvas.addEventListener('pointerup', ()=> {
  if(!pathState.running){ pathState.running = true; pathLoop(); notify('Path running'); }
});

function pathLoop(){
  if(!pathState.running) return;
  // scroll world
  pathState.worldOffset += pathState.speed;
  pathState.spawnTick += pathState.speed;
  if(pathState.spawnTick > 300){
    pathState.spawnTick = 0;
    const lastX = pathState.obstacles.length ? pathState.obstacles[pathState.obstacles.length-1].x + 200 + Math.random()*200 : pathState.worldOffset + 900;
    pathState.obstacles.push({x:lastX, y:60 + Math.random()*(drawCanvas.height-140), w:40 + Math.random()*60, h:30 + Math.random()*40});
    pathState.speed = Math.min(6, pathState.speed + 0.05);
  }
  // follow next point ahead
  if(pathState.points.length > 0){
    let targetIndex = 0;
    while(targetIndex < pathState.points.length && pathState.points[targetIndex].x < pathState.worldOffset + pathState.car.x) targetIndex++;
    if(targetIndex >= pathState.points.length) targetIndex = pathState.points.length - 1;
    const target = pathState.points[targetIndex];
    const tx = target.x - pathState.worldOffset;
    const ty = target.y;
    pathState.car.x += (tx - pathState.car.x) * 0.12;
    pathState.car.y += (ty - pathState.car.y) * 0.12;
    if(Math.hypot(tx - pathState.car.x, ty - pathState.car.y) < 6) {
      pathState.points = pathState.points.slice(Math.max(0, targetIndex - 2));
    }
  } else {
    pathState.car.x += 0.6;
  }
  // collision
  for(const ob of pathState.obstacles){
    const sx = ob.x - pathState.worldOffset;
    if(pathState.car.x + pathState.car.r > sx && pathState.car.x - pathState.car.r < sx + ob.w &&
       pathState.car.y + pathState.car.r > ob.y && pathState.car.y - pathState.car.r < ob.y + ob.h){
      if(hearts > 0){ hearts--; saveState(); pathState.car.x = 120; pathState.car.y = drawCanvas.height/2; pathState.points = []; pathState.running = false; notify('Heart used'); return; }
      if(coins >= 15) coins = 5; else coins = 0; saveState(); updateHUD();
      pathState.car.x = 120; pathState.car.y = drawCanvas.height/2; pathState.points = []; pathState.running = false; notify('Hit obstacle â€” back to start'); return;
    }
  }
  drawPathOnce();
  rafHandle = requestAnimationFrame(pathLoop);
}

// ---------- Helpers ----------
function saveState(){ localStorage.setItem('pa_coins', coins); localStorage.setItem('pa_hearts', hearts); updateHUD(); }
function updateHUD(){ coinsEl.textContent = coins; heartsEl.textContent = hearts; }

// ---------- drawCurrentView and initialization ----------
function drawCurrentView(){ if(currentGame === 'flap') drawFlapOnce(); if(currentGame === 'runner') drawRunnerOnce(); if(currentGame === 'match') renderMatch(); if(currentGame === 'path') drawPathOnce(); }
fitAndStart();
function fitAndStart(){ fitCanvases(); showGameView('flap'); setupObjectButton(); initMatch(); }

// --------- Stop on page unload ----------
window.addEventListener('beforeunload', ()=> saveState());

</script>
</body>
</html>

