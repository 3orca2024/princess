<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Princess Arcade â€” Ultimate</title>
<style>
  :root{
    --accent:#ff5aa2;
    --muted:#5b3b51;
    --soft:#fff7ff;
    --card:#fffafc;
    --bg0:#ffdff6;
    --glass: rgba(255,255,255,0.85);
  }
  html,body{height:100%;margin:0;font-family:Inter, system-ui, -apple-system, "Segoe UI", Roboto, Arial;background:var(--bg0);-webkit-font-smoothing:antialiased}
  .app{max-width:1180px;margin:18px auto;padding:18px;background:var(--glass);border-radius:14px;box-shadow:0 18px 44px rgba(0,0,0,0.08)}
  header{display:flex;align-items:center;justify-content:space-between;gap:12px}
  h1{margin:0;color:var(--muted);font-size:20px}
  .top-right{display:flex;gap:12px;align-items:center}
  .badge{background:white;padding:8px 12px;border-radius:12px;box-shadow:0 6px 18px rgba(0,0,0,0.06);font-weight:700}
  .prin-bar{display:flex;gap:8px;overflow:auto;padding:10px;margin-top:12px;border-radius:12px;background:linear-gradient(90deg,#fff,#fff0)}
  .prin{width:88px;flex:0 0 auto;border-radius:10px;padding:6px;background:var(--card);text-align:center;cursor:pointer;border:2px solid transparent;transition:transform .16s,box-shadow .16s}
  .prin.selected{transform:translateY(-8px);border-color:var(--accent);box-shadow:0 10px 30px rgba(255,90,150,0.14)}
  .avatar{width:68px;height:68px;border-radius:8px;display:block;margin:0 auto 6px auto}
  .small{font-size:13px;color:#5b3b51}
  .main{display:flex;gap:14px;margin-top:14px}
  .left{flex:1}
  .right{width:360px}
  .card{background:linear-gradient(180deg,#fff,#fff0);padding:12px;border-radius:12px;box-shadow:0 8px 18px rgba(0,0,0,0.06)}
  .tabs{display:flex;gap:8px;flex-wrap:wrap}
  .tab{padding:8px 10px;border-radius:8px;background:#fff;border:1px solid #eee;cursor:pointer}
  .tab.active{background:linear-gradient(180deg,var(--accent),#ff2f86);color:white;border:none}
  canvas{width:100%;height:360px;border-radius:10px;background:transparent;display:block}
  #blockCanvas{height:170px}
  .hud{display:flex;gap:12px;align-items:center;margin-top:8px}
  .btn{padding:8px 12px;border-radius:10px;border:none;background:var(--accent);color:white;cursor:pointer}
  .btn.ghost{background:transparent;border:1px solid #eee;color:#333}
  .instructions{margin-top:10px;padding:10px;border-radius:10px;background:#fff}
  #shopModal,#instrModal{position:fixed;left:0;top:0;right:0;bottom:0;background:rgba(0,0,0,0.45);display:none;align-items:center;justify-content:center;z-index:500}
  .modalCard{width:640px;background:white;padding:18px;border-radius:12px;max-height:80vh;overflow:auto}
  .flex{display:flex;gap:8px;align-items:center}
  .dragBlock{width:80px;height:36px;border-radius:8px;display:inline-flex;align-items:center;justify-content:center;color:white;margin:6px;cursor:grab}
  .notify{position:fixed;left:50%;transform:translateX(-50%);top:18px;background:linear-gradient(90deg,#fff,#fff0);padding:8px 14px;border-radius:12px;box-shadow:0 10px 28px rgba(0,0,0,0.12);display:none;z-index:600}
  footer{margin-top:12px;color:#876572;font-size:13px}
  @media (max-width:980px){.main{flex-direction:column}.right{width:100%}canvas{height:300px}}
</style>
</head>
<body>
  <div class="app" id="app">
    <header>
      <div>
        <h1>Princess Arcade â€” Ultimate</h1>
        <div class="small">Pick a princess & play â€” coins & hearts carry across games!</div>
      </div>
      <div class="top-right">
        <div class="badge">Coins: <span id="coins">0</span></div>
        <div class="badge">Hearts: <span id="hearts">0</span></div>
        <button id="openShop" class="btn">Shop</button>
        <button id="openInstr" class="btn ghost">Instructions</button>
      </div>
    </header>

    <!-- Princess selector (SVG avatars generated in JS) -->
    <div class="prin-bar" id="prinBar" aria-label="Princess picker">
      <!-- template: each element will be given an image by JS -->
      <div class="prin" data-name="Ariel" data-object="seashell" data-color="#ff7fbf"><img class="avatar" id="Ariel"><div class="small">Ariel</div></div>
      <div class="prin" data-name="Elsa" data-object="snowflake" data-color="#cfe7ff"><img class="avatar" id="Elsa"><div class="small">Elsa</div></div>
      <div class="prin" data-name="Moana" data-object="wave" data-color="#9fd4ff"><img class="avatar" id="Moana"><div class="small">Moana</div></div>
      <div class="prin" data-name="Mulan" data-object="sword" data-color="#ffd6e9"><img class="avatar" id="Mulan"><div class="small">Mulan</div></div>
      <div class="prin" data-name="Cinderella" data-object="slipper" data-color="#cfe0ff"><img class="avatar" id="Cinderella"><div class="small">Cinderella</div></div>
      <div class="prin" data-name="Rapunzel" data-object="lizard" data-color="#f7d06a"><img class="avatar" id="Rapunzel"><div class="small">Rapunzel</div></div>
      <div class="prin" data-name="Tiana" data-object="frog" data-color="#9be9b6"><img class="avatar" id="Tiana"><div class="small">Tiana</div></div>
      <div class="prin" data-name="Belle" data-object="book" data-color="#ffd07a"><img class="avatar" id="Belle"><div class="small">Belle</div></div>
    </div>

    <div style="margin-top:12px" class="card">
      <div class="tabs" id="tabs">
        <div class="tab active" data-game="flap">Flappy Princess</div>
        <div class="tab" data-game="block">Block Blast</div>
        <div class="tab" data-game="runner">Princess Runner</div>
        <div class="tab" data-game="match">Match Game</div>
        <div class="tab" data-game="path">Draw-a-Path</div>
      </div>

      <div class="main">
        <div class="left">
          <div class="card" style="padding:12px">
            <canvas id="mainCanvas" width="900" height="360"></canvas>
            <canvas id="blockCanvas" width="900" height="170" style="display:none; margin-top:8px; border-radius:8px;"></canvas>

            <div class="hud" style="margin-top:8px;">
              <div class="small">Selected: <strong id="selName">None</strong></div>
              <div style="flex:1"></div>
              <div class="small" id="countdownDisplay"></div>
              <button id="startBtn" class="btn">Start</button>
              <button id="resetBtn" class="btn ghost">Reset</button>
            </div>

            <div class="instructions" id="instrBox">Choose a game tab and press Start. Open instructions for full rules.</div>
          </div>
        </div>

        <div class="right">
          <div class="card">
            <h4 style="margin:0">Shop & Game Tips</h4>
            <div style="margin-top:8px" class="small">Use coins collected in any game to buy hearts (30 coins each). Hearts let your princess survive a hit and return to the start.</div>
            <div style="height:12px"></div>
            <div class="card" style="margin-top:6px">
              <h5 style="margin:6px 0">Block Blast â€” Drag Blocks</h5>
              <div class="small">Three draggable blocks appear under the grid. Drag them into empty grid cells. If any full row or column forms, it disappears and you gain 5 coins.</div>
              <div id="dragTray" style="margin-top:8px;display:flex;flex-wrap:wrap"></div>
            </div>
            <div style="height:12px"></div>
            <div class="card" style="margin-top:8px">
              <h5 style="margin:4px 0">Match Game â€” Flip cards</h5>
              <div class="small">12 cards, 6 pairs (princess objects). Flip two cards each turn; matching pairs disappear.</div>
            </div>
          </div>
        </div>
      </div>

      <footer style="margin-top:10px">Made for you â€” play, collect coins, buy hearts, and have fun! ðŸ’–</footer>
    </div>
  </div>

  <!-- Shop modal -->
  <div id="shopModal">
    <div class="modalCard">
      <h3>Shop â€” Hearts & Info</h3>
      <p class="small">Hearts cost <strong>30 coins</strong>. Hearts let your princess survive a hit and return to the start instead of losing coins.</p>
      <p class="small">You have <strong id="modalCoins">0</strong> coins and <strong id="modalHearts">0</strong> hearts.</p>
      <div style="display:flex;gap:8px;justify-content:flex-end;margin-top:12px">
        <button id="buyHeart" class="btn">Buy Heart (30)</button>
        <button id="closeShop" class="btn ghost">Close</button>
      </div>
    </div>
  </div>

  <!-- Instructions modal -->
  <div id="instrModal">
    <div class="modalCard">
      <h3>Instructions â€” All Games</h3>
      <div style="margin-top:8px">
        <h4>Flappy Princess</h4>
        <p class="small">Press SPACE or click/tap to flap. Each princess has a special obstacle (seashell, snowflake, wave, sword, slipper, lizard, frog, book). Avoid obstacles â€” hitting one returns your princess to the start. Passing obstacles earns coins.</p>

        <h4>Block Blast</h4>
        <p class="small">Drag any of the 3 blocks from the tray into grid cells. When a full row or column is filled, it clears and you get 5 coins. Blocks snap to cells.</p>

        <h4>Princess Runner</h4>
        <p class="small">Choose your princess object and press Start. You get a 3-2-1 countdown. Click/tap or press SPACE to jump and dodge obstacles. Hitting an obstacle returns you to start or consumes a heart.</p>

        <h4>Match Game</h4>
        <p class="small">12 cards, 6 pairs. Tap to flip; flip two cards each turn. Matching pair disappears. Clear all to win coins.</p>

        <h4>Draw-a-Path</h4>
        <p class="small">Draw a path for the princess car with your finger or mouse. The car follows the path; draw around obstacles to avoid them. Reach the end to win coins.</p>

        <div style="height:8px"></div>
        <button id="closeInstr" class="btn" style="float:right">Close</button>
      </div>
    </div>
  </div>

  <div class="notify" id="notify"></div>

<script>
/* Princess Arcade â€” All games in one file
   Key features implemented per Emilyp's spec:
   - Flappy with per-princess obstacles (objects), space to flap / click
   - Block Blast: blank grid + 3 draggable blocks; row/column clears for +5 coins
   - Runner: countdown, tap/space to jump; smaller hitbox and restart to start
   - Match Game: 12 cards (6 pairs) with princess objects
   - Draw-a-Path: draw path for car, car follows and must avoid obstacles
   - Shop modal and Instructions modal (no alerts)
   - Notifications via in-page notify box
   - Coins/hearts persisted via localStorage
*/

// ---------- Persistence & HUD ----------
let coins = Number(localStorage.getItem('arcade_coins') || 0);
let hearts = Number(localStorage.getItem('arcade_hearts') || 0);
const coinsEl = document.getElementById('coins');
const heartsEl = document.getElementById('hearts');
function saveState(){ localStorage.setItem('arcade_coins', coins); localStorage.setItem('arcade_hearts', hearts); updateHUD(); }
function updateHUD(){ coinsEl.textContent = coins; heartsEl.textContent = hearts; document.getElementById('modalCoins').textContent = coins; document.getElementById('modalHearts').textContent = hearts; }
updateHUD();

function notify(text, time=2000){
  const n = document.getElementById('notify');
  n.textContent = text; n.style.display='block';
  clearTimeout(n._t);
  n._t = setTimeout(()=> n.style.display='none', time);
}

// ---------- Princess data & avatars (SVG data URIs) ----------
const princessData = [
  {name:'Ariel', object:'seashell', color:'#ff7fbf'},
  {name:'Elsa', object:'snowflake', color:'#cfe7ff'},
  {name:'Moana', object:'wave', color:'#9fd4ff'},
  {name:'Mulan', object:'sword', color:'#ffd6e9'},
  {name:'Cinderella', object:'slipper', color:'#cfe0ff'},
  {name:'Rapunzel', object:'lizard', color:'#f7d06a'},
  {name:'Tiana', object:'frog', color:'#9be9b6'},
  {name:'Belle', object:'book', color:'#ffd07a'}
];

function makeAvatar(name, color){
  const initials = name.split(' ').map(s=>s[0]).join('').slice(0,2).toUpperCase();
  const svg = `<svg xmlns='http://www.w3.org/2000/svg' width='160' height='160'>
    <rect rx='18' width='100%' height='100%' fill='${color}' />
    <circle cx='80' cy='48' r='30' fill='rgba(255,255,255,0.12)' />
    <text x='80' y='56' text-anchor='middle' font-size='30' font-family='Arial' fill='white' font-weight='700'>${initials}</text>
    <text x='80' y='120' text-anchor='middle' font-size='18' font-family='Arial' fill='rgba(70,40,60,0.95)'>${name}</text>
  </svg>`;
  return 'data:image/svg+xml;utf8,' + encodeURIComponent(svg);
}

// assign avatars into DOM
document.querySelectorAll('.prin').forEach(pr=>{
  const name = pr.dataset.name;
  const data = princessData.find(p=>p.name === name);
  const img = pr.querySelector('.avatar');
  img.src = makeAvatar(name, data ? data.color : '#ddd');
});

// selected princess
let selected = null;
document.querySelectorAll('.prin').forEach(pr=>{
  pr.addEventListener('click', ()=>{
    document.querySelectorAll('.prin').forEach(x=>x.classList.remove('selected'));
    pr.classList.add('selected');
    selected = {
      name: pr.dataset.name,
      object: pr.dataset.object,
      color: pr.dataset.color,
      svg: makeAvatar(pr.dataset.name, pr.dataset.color)
    };
    document.getElementById('selName').textContent = selected.name;
    notify(`${selected.name} selected!`);
  });
});

// ---------- Tabs ----------
let currentGame = 'flap';
document.querySelectorAll('.tab').forEach(t=>{
  t.addEventListener('click', ()=>{
    document.querySelectorAll('.tab').forEach(x=>x.classList.remove('active'));
    t.classList.add('active');
    currentGame = t.dataset.game;
    document.getElementById('instrBox').textContent = `Ready to play ${t.textContent}. Press Start to begin.`;
    prepareView();
  });
});

// modals: shop & instructions
const shopModal = document.getElementById('shopModal');
const instrModal = document.getElementById('instrModal');
document.getElementById('openShop').addEventListener('click', ()=> { updateHUD(); shopModal.style.display='flex'; });
document.getElementById('closeShop').addEventListener('click', ()=> shopModal.style.display='none');
document.getElementById('openInstr').addEventListener('click', ()=> instrModal.style.display='flex');
document.getElementById('closeInstr').addEventListener('click', ()=> instrModal.style.display='none');
document.getElementById('buyHeart').addEventListener('click', ()=> {
  if(coins >= 30){ coins -= 30; hearts++; saveState(); notify('Bought a heart!'); } else notify('Need 30 coins for a heart.');
});

// ---------- Canvas setup ----------
const mainCanvas = document.getElementById('mainCanvas');
const ctx = mainCanvas.getContext('2d');
const blockCanvas = document.getElementById('blockCanvas');
const bctx = blockCanvas.getContext('2d');

function clearMain(){
  ctx.clearRect(0,0,mainCanvas.width, mainCanvas.height);
  ctx.fillStyle = '#fff7ff'; ctx.fillRect(0,0,mainCanvas.width, mainCanvas.height);
  ctx.fillStyle = '#5b3b51'; ctx.font='18px sans-serif'; ctx.textAlign='center';
  ctx.fillText('Pick a game & princess, then press Start', mainCanvas.width/2, mainCanvas.height/2);
}
clearMain();

// Start / Reset buttons
document.getElementById('startBtn').addEventListener('click', startCurrentGame);
document.getElementById('resetBtn').addEventListener('click', resetCurrentGame);

// countdown display
const countdownEl = document.getElementById('countdownDisplay');

// -----------------------------------------------------------
// GAME: FLAP (Flappy Dunk) with distinct object obstacles
// -----------------------------------------------------------
const FLAP = {
  running:false,
  princess:{x:140,y:180,vy:0,w:56,h:56},
  gravity:0.9, flapPower:-12,
  obstacles:[], frames:0, score:0, spawnRate:90
};

function flapReset(){
  FLAP.princess.y = mainCanvas.height/2;
  FLAP.princess.vy = 0;
  FLAP.obstacles = [];
  FLAP.frames = 0;
  FLAP.score = 0;
  drawFlap(); applyHUD();
}

function spawnFlapObstacle(){
  // create obstacle with princess-specific icon (drawn)
  const gap = 0; // single obstacle objects (not pipes). We'll place boxes representing objects to dodge.
  const h = 32 + Math.random()*120;
  const y = Math.random()*(mainCanvas.height-140) + 60;
  FLAP.obstacles.push({x: mainCanvas.width + 20, y:y, w:46, h:h, speed:3 + Math.random()*1.6});
}

function flapUpdate(){
  FLAP.frames++;
  // spawn obstacles more frequently as score increases
  const rate = Math.max(45, FLAP.spawnRate - Math.floor(FLAP.score/6));
  if(FLAP.frames % rate === 0) spawnFlapObstacle();
  // physics
  FLAP.princess.vy += FLAP.gravity * 0.6;
  FLAP.princess.y += FLAP.princess.vy;
  const ground = mainCanvas.height - 62;
  if(FLAP.princess.y > ground){ FLAP.princess.y = ground; FLAP.princess.vy = 0; }
  if(FLAP.princess.y < 16){ FLAP.princess.y = 16; FLAP.princess.vy = 0; }
  // move obstacles
  for(let i=FLAP.obstacles.length-1;i>=0;i--){
    FLAP.obstacles[i].x -= FLAP.obstacles[i].speed + Math.min(4, FLAP.score/60);
    if(FLAP.obstacles[i].x + FLAP.obstacles[i].w < -20){ FLAP.obstacles.splice(i,1); FLAP.score++; coins += 1; saveState(); updateHUD(); }
  }
  // collision detection with tighter hitbox
  const px = FLAP.princess.x - FLAP.princess.w*0.25, py = FLAP.princess.y - FLAP.princess.h*0.25;
  const pw = FLAP.princess.w*0.5, ph = FLAP.princess.h*0.5;
  for(const ob of FLAP.obstacles){
    if(px < ob.x + ob.w && px + pw > ob.x && py < ob.y + ob.h && py + ph > ob.y){
      // hit: if has hearts, consume one and teleport to start; otherwise apply coin keep rule and stop
      if(hearts > 0){ hearts--; saveState(); notify('Heart used â€” back to start'); FLAP.princess.y = mainCanvas.height/2; FLAP.obstacles = []; return; }
      // keep-5 rule
      if(coins >= 15){ coins = 5; } else coins = 0;
      saveState(); updateHUD();
      FLAP.running = false;
      FLAP.princess.y = mainCanvas.height/2;
      FLAP.obstacles = [];
      notify('You hit an obstacle â€” back to start');
      return;
    }
  }
}

function drawPrincess(x,y,size){
  // draw selected princess SVG if available
  if(selected && selected.svg){
    const img = new Image();
    img.src = selected.svg;
    img.onload = ()=> ctx.drawImage(img, x - size/2, y - size/2, size, size);
    img.onerror = ()=>{
      ctx.fillStyle = selected ? selected.color : '#c0a0ff';
      ctx.beginPath(); ctx.arc(x,y,size/2,0,Math.PI*2); ctx.fill();
    };
  } else {
    ctx.fillStyle = '#c0a0ff'; ctx.beginPath(); ctx.arc(x,y,size/2,0,Math.PI*2); ctx.fill();
  }
}

function drawFlap(){
  ctx.clearRect(0,0,mainCanvas.width, mainCanvas.height);
  // soft gradient bg
  const g = ctx.createLinearGradient(0,0,0,mainCanvas.height);
  g.addColorStop(0,'#ffdff6'); g.addColorStop(1,'#fff7ff');
  ctx.fillStyle = g; ctx.fillRect(0,0,mainCanvas.width, mainCanvas.height);
  // ground
  ctx.fillStyle = 'rgba(255,255,255,0.9)'; ctx.fillRect(0, mainCanvas.height-62, mainCanvas.width, 62);
  // princess
  drawPrincess(FLAP.princess.x, FLAP.princess.y, FLAP.princess.w);
  // obstacles (draw object icon for each obstacle)
  FLAP.obstacles.forEach(ob => {
    // base box
    ctx.fillStyle = '#7a1b5a'; ctx.fillRect(ob.x, ob.y, ob.w, ob.h);
    // draw the princess object icon on the obstacle to match selected princess (if selected)
    if(selected){
      drawObjectIcon(ctx, ob.x + ob.w/2, ob.y + ob.h/2, selected.object, 18);
    } else {
      ctx.fillStyle = '#fff'; ctx.font='12px sans-serif'; ctx.textAlign='center'; ctx.fillText('OBJ', ob.x + ob.w/2, ob.y + ob.h/2 + 4);
    }
  });
  // hud
  ctx.fillStyle = '#5b3b51'; ctx.font='14px sans-serif'; ctx.fillText(`Score: ${FLAP.score}`, 12, 22);
}

function flapLoop(){
  if(!FLAP.running) return;
  flapUpdate();
  drawFlap();
  requestAnimationFrame(flapLoop);
}

// space / click control for flap
window.addEventListener('keydown', (e)=>{
  if(e.code === 'Space'){
    if(currentGame === 'flap' && FLAP.running){ FLAP.princess.vy = FLAP.flapPower; e.preventDefault(); }
    if(currentGame === 'runner' && countdown===0 && !runner.running){ /* no-op */ }
  }
});
mainCanvas.addEventListener('pointerdown', (e)=>{
  if(currentGame === 'flap' && FLAP.running){ FLAP.princess.vy = FLAP.flapPower; }
});

// draw simple object icons (hand-drawn-ish) for obstacles
function drawObjectIcon(ctx, cx, cy, obj, size){
  ctx.save();
  ctx.translate(cx, cy);
  switch(obj){
    case 'seashell':
      ctx.fillStyle = '#fff1f6';
      ctx.beginPath();
      ctx.moveTo(-size/2,0);
      for(let i=0;i<6;i++){
        const a = Math.PI * (i/6);
        ctx.lineTo(-Math.cos(a)*size/2, Math.sin(a)*size/3);
      }
      ctx.closePath(); ctx.fill();
      break;
    case 'snowflake':
      ctx.strokeStyle = '#e6f7ff'; ctx.lineWidth = 2;
      for(let i=0;i<6;i++){
        ctx.beginPath(); ctx.moveTo(0,0); const a = i*Math.PI/3; ctx.lineTo(Math.cos(a)*size/2, Math.sin(a)*size/2); ctx.stroke();
      }
      break;
    case 'wave':
      ctx.fillStyle = '#d0f0ff';
      ctx.beginPath(); ctx.arc(-size/6, 0, size/3, Math.PI*0.2, Math.PI*1.2); ctx.arc(size/6, 0, size/3, Math.PI*0.2, Math.PI*1.2); ctx.fill();
      break;
    case 'sword':
      ctx.fillStyle = '#e6e6e6'; ctx.fillRect(-2, -size/2, 4, size);
      ctx.fillStyle='#cfcfcf'; ctx.fillRect(-8, size/2 - 6, 16, 6);
      break;
    case 'slipper':
      ctx.fillStyle = '#fff2ff'; ctx.beginPath(); ctx.moveTo(-size/2, 0); ctx.quadraticCurveTo(0,-size/2, size/2,0); ctx.lineTo(size/2-6, size/3); ctx.quadraticCurveTo(0, size/2, -size/2, size/3); ctx.fill();
      break;
    case 'lizard':
      ctx.fillStyle = '#b8f0a8'; ctx.beginPath(); ctx.ellipse(0,0,size/2, size/3, 0, 0, Math.PI*2); ctx.fill();
      break;
    case 'frog':
      ctx.fillStyle = '#9fe6a8'; ctx.beginPath(); ctx.arc(-6, -4, size/6, 0, Math.PI*2); ctx.arc(10, -4, size/6, 0, Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.arc(2,6,size/3,0,Math.PI*2); ctx.fill();
      break;
    case 'book':
      ctx.fillStyle = '#fff8e6'; ctx.fillRect(-size/3, -size/4, size*2/3, size/2); ctx.strokeStyle='#c9b08a'; ctx.strokeRect(-size/3, -size/4, size*2/3, size/2); break;
    default:
      ctx.fillStyle = '#fff'; ctx.fillRect(-size/3, -size/3, size*2/3, size*2/3);
  }
  ctx.restore();
}

// -----------------------------------------------------------
// GAME: BLOCK BLAST (grid with drag & snap 3 blocks)
// -----------------------------------------------------------
const GRID_COLS = 10, GRID_ROWS = 6;
const grid = Array.from({length:GRID_ROWS}, ()=>Array(GRID_COLS).fill(0));
const cellW = blockCanvas.width / GRID_COLS;
const cellH = blockCanvas.height / GRID_ROWS;
const dragTray = document.getElementById('dragTray');
const blockTypes = [
  {id:'bb1', color:'#ff7fbf'},
  {id:'bb2', color:'#ffd07a'},
  {id:'bb3', color:'#9fc9ff'}
];

// create draggable block elements
blockTypes.forEach(b=>{
  const el = document.createElement('div');
  el.className = 'dragBlock';
  el.style.background = b.color;
  el.dataset.id = b.id;
  el.textContent = 'DRAG';
  dragTray.appendChild(el);
  // pointer event
  el.addEventListener('pointerdown', startDragBlock);
});

let dragging = null; // {el, id, startRect}
function startDragBlock(e){
  if(currentGame !== 'block') return;
  const el = e.currentTarget;
  dragging = {el, id: el.dataset.id, startParent: el.parentElement};
  el.setPointerCapture(e.pointerId);
  el.style.position = 'absolute'; el.style.zIndex = 99999;
  document.body.appendChild(el);
  moveDrag(e);
  document.addEventListener('pointermove', moveDrag);
  document.addEventListener('pointerup', dropDragBlock);
}
function moveDrag(e){
  if(!dragging) return;
  dragging.el.style.left = e.pageX - 40 + 'px';
  dragging.el.style.top = e.pageY - 18 + 'px';
}
function dropDragBlock(e){
  if(!dragging) return;
  // check if over blockCanvas
  const rect = blockCanvas.getBoundingClientRect();
  const x = e.clientX, y = e.clientY;
  if(x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom){
    const localX = (x - rect.left) * (blockCanvas.width / rect.width);
    const localY = (y - rect.top) * (blockCanvas.height / rect.height);
    const c = Math.floor(localX / cellW);
    const r = Math.floor(localY / cellH);
    if(r >= 0 && r < GRID_ROWS && c >= 0 && c < GRID_COLS){
      if(grid[r][c] === 0){
        grid[r][c] = 1; // place block
        notify('Block placed!');
        checkGridClear();
      } else {
        notify('Cell is occupied');
      }
    }
  }
  // return element to tray
  dragging.el.style.position = 'static'; dragging.el.style.left = ''; dragging.el.style.top = '';
  dragging.startParent.appendChild(dragging.el);
  dragging = null;
  document.removeEventListener('pointermove', moveDrag);
  document.removeEventListener('pointerup', dropDragBlock);
  drawGrid();
}

function drawGrid(){
  bctx.clearRect(0,0,blockCanvas.width, blockCanvas.height);
  bctx.fillStyle = '#fff7ff'; bctx.fillRect(0,0,blockCanvas.width, blockCanvas.height);
  for(let r=0;r<GRID_ROWS;r++){
    for(let c=0;c<GRID_COLS;c++){
      const x = c*cellW, y = r*cellH;
      bctx.fillStyle = grid[r][c] ? '#7a1b5a' : '#fff';
      bctx.fillRect(x+2,y+2,cellW-4,cellH-4);
      bctx.strokeStyle = '#e6d6e6'; bctx.strokeRect(x+2,y+2,cellW-4,cellH-4);
    }
  }
}

function checkGridClear(){
  // check rows
  for(let r=0;r<GRID_ROWS;r++){
    let full = true;
    for(let c=0;c<GRID_COLS;c++){ if(grid[r][c] === 0) { full = false; break; } }
    if(full){
      // clear row
      for(let c=0;c<GRID_COLS;c++) grid[r][c] = 0;
      // move down above rows
      for(let rr=r; rr>0; rr--){
        for(let c=0;c<GRID_COLS;c++){ grid[rr][c] = grid[rr-1][c]; }
      }
      for(let c=0;c<GRID_COLS;c++) grid[0][c] = 0;
      coins += 5; saveState(); notify('Row cleared! +5 coins');
    }
  }
  // check columns
  for(let c=0;c<GRID_COLS;c++){
    let full = true;
    for(let r=0;r<GRID_ROWS;r++){ if(grid[r][c] === 0) { full = false; break; } }
    if(full){
      // clear column
      for(let r=0;r<GRID_ROWS;r++) grid[r][c] = 0;
      coins += 5; saveState(); notify('Column cleared! +5 coins');
      // collapse left?
      // to keep behavior simple we won't shift columns for now
    }
  }
  drawGrid();
}

// -----------------------------------------------------------
// GAME: RUNNER (countdown then jump, improved hitbox)
// -----------------------------------------------------------
let countdown = 0;
const runner = {
  running:false,
  player:{x:80,y:260,vy:0,w:36,h:36,groundY:mainCanvas.height - 86},
  gravity:0.9, jump:-14, obstacles:[], frames:0, score:0, coinsOnTrack:[]
};

function runnerReset(){
  runner.player.y = runner.player.groundY; runner.player.vy = 0; runner.obstacles = []; runner.frames = 0; runner.score = 0; runner.coinsOnTrack = []; drawRunner();
}
function spawnRunnerObstacle(){ runner.obstacles.push({x: mainCanvas.width + 20, y: runner.player.groundY - 6, w:36, h:36, speed:4 + Math.random()*1.6}); }
function spawnRunnerCoin(){ runner.coinsOnTrack.push({x: mainCanvas.width + 60, y: runner.player.groundY - 60, r:8}); }

function runnerUpdate(){
  runner.frames++;
  if(runner.frames % 90 === 0) spawnRunnerObstacle();
  if(runner.frames % 140 === 0) spawnRunnerCoin();
  runner.player.vy += runner.gravity;
  runner.player.y += runner.player.vy;
  if(runner.player.y > runner.player.groundY){ runner.player.y = runner.player.groundY; runner.player.vy = 0; }
  // obstacles move
  for(let i=runner.obstacles.length-1;i>=0;i--){
    const ob = runner.obstacles[i];
    ob.x -= ob.speed;
    if(ob.x + ob.w < -20){ runner.obstacles.splice(i,1); runner.score++; coins += 1; saveState(); }
  }
  // coins move & collect
  for(let i=runner.coinsOnTrack.length-1;i>=0;i--){
    const c = runner.coinsOnTrack[i]; c.x -= 3;
    const dx = c.x - (runner.player.x + runner.player.w/2); const dy = c.y - (runner.player.y + runner.player.h/2);
    if(Math.hypot(dx,dy) < 22){ runner.coinsOnTrack.splice(i,1); coins += 1; saveState(); notify('+1 coin'); }
    if(c.x < -20) runner.coinsOnTrack.splice(i,1);
  }
  // collision with tighter hitbox (shrink player's box)
  const px = runner.player.x + runner.player.w*0.15, py = runner.player.y + runner.player.h*0.1;
  const pw = runner.player.w * 0.7, ph = runner.player.h * 0.8;
  for(const ob of runner.obstacles){
    if(px < ob.x + ob.w && px + pw > ob.x && py < ob.y + ob.h && py + ph > ob.y){
      if(hearts > 0){ hearts--; saveState(); notify('Heart used â€” back to start'); runner.player.y = runner.player.groundY; runner.obstacles = []; return; }
      // keep coins rule
      if(coins >= 15) coins = 5; else coins = 0; saveState(); updateHUD();
      runner.running = false;
      runner.player.y = runner.player.groundY; runner.obstacles = [];
      notify('You hit an obstacle â€” back to start');
      return;
    }
  }
}

function drawRunner(){
  ctx.clearRect(0,0,mainCanvas.width, mainCanvas.height);
  // bg
  const g = ctx.createLinearGradient(0,0,0,mainCanvas.height);
  g.addColorStop(0,'#fff8fb'); g.addColorStop(1,'#fff');
  ctx.fillStyle = g; ctx.fillRect(0,0,mainCanvas.width,mainCanvas.height);
  // ground
  ctx.fillStyle = '#fff'; ctx.fillRect(0, mainCanvas.height-86, mainCanvas.width, 86);
  // player image
  drawPrincess(runner.player.x + runner.player.w/2, runner.player.y + runner.player.h/2, runner.player.w);
  // obstacles
  ctx.fillStyle = '#7a1b5a'; runner.obstacles.forEach(ob => ctx.fillRect(ob.x, ob.y, ob.w, ob.h));
  // coins
  ctx.fillStyle = '#ffd34d'; runner.coinsOnTrack.forEach(c => { ctx.beginPath(); ctx.arc(c.x,c.y,c.r,0,Math.PI*2); ctx.fill(); });
  // HUD
  ctx.fillStyle='#5b3b51'; ctx.font='14px sans-serif'; ctx.fillText(`Distance: ${runner.score}`, 12, 20);
}

function runnerLoop(){
  if(!runner.running) return;
  runnerUpdate();
  drawRunner();
  requestAnimationFrame(runnerLoop);
}

window.addEventListener('keydown', (e)=> {
  if(e.code === 'Space'){
    if(currentGame === 'runner' && runner.running){ if(runner.player.y >= runner.player.groundY) runner.player.vy = runner.jump; }
    if(currentGame === 'match'){} // no-op
  }
});
mainCanvas.addEventListener('pointerdown', (e)=>{
  if(currentGame === 'runner' && runner.running){ if(runner.player.y >= runner.player.groundY) runner.player.vy = runner.jump; }
});

// -----------------------------------------------------------
// GAME: MATCH GAME (12 cards, 6 pairs of objects)
// -----------------------------------------------------------
const MATCH_OBJECTS = ['seashell','snowflake','wave','sword','slipper','lizard','frog','book'];
let matchState = {cards:[], flipped:[], removed:0};
function initMatch(){
  // use first 6 unique objects from princess list
  const objs = MATCH_OBJECTS.slice(0,6);
  let deck = objs.concat(objs); // 12
  // shuffle
  for(let i=0;i<200;i++){ const a=Math.floor(Math.random()*12), b=Math.floor(Math.random()*12); [deck[a],deck[b]]=[deck[b],deck[a]]; }
  matchState.cards = deck.map((obj,i)=>({id:i,obj,faceUp:false,removed:false}));
  matchState.flipped = []; matchState.removed = 0;
  drawMatch();
}

function drawMatch(){
  ctx.clearRect(0,0,mainCanvas.width, mainCanvas.height);
  ctx.fillStyle = '#fff7ff'; ctx.fillRect(0,0,mainCanvas.width, mainCanvas.height);
  const cols = 4, rows = 3;
  const w = 120, h = 120, gap = 16;
  const startX = (mainCanvas.width - (cols*w + (cols-1)*gap))/2;
  const startY = 30;
  ctx.font='20px sans-serif'; ctx.textAlign='center'; ctx.textBaseline='middle';
  matchState.cards.forEach((card, idx)=>{
    const r = Math.floor(idx/cols), c = idx%cols;
    const x = startX + c*(w+gap), y = startY + r*(h+gap);
    if(card.removed) return;
    if(card.faceUp){
      // draw object image
      ctx.fillStyle = '#7a1b5a'; ctx.fillRect(x,y,w,h);
      drawObjectIcon(ctx, x + w/2, y + h/2, card.obj, 28);
    } else {
      ctx.fillStyle = '#fff'; ctx.fillRect(x,y,w,h);
      ctx.fillStyle = '#e6d6e6'; ctx.strokeRect(x,y,w,h);
      ctx.fillStyle = '#5b3b51'; ctx.fillText('?', x + w/2, y + h/2);
    }
  });
}

// click to flip cards
mainCanvas.addEventListener('pointerdown', (e)=>{
  if(currentGame !== 'match') return;
  const rect = mainCanvas.getBoundingClientRect();
  const mx = (e.clientX - rect.left) * (mainCanvas.width / rect.width);
  const my = (e.clientY - rect.top) * (mainCanvas.height / rect.height);
  const cols = 4, rows = 3;
  const w = 120, h = 120, gap = 16;
  const startX = (mainCanvas.width - (cols*w + (cols-1)*gap))/2;
  const startY = 30;
  for(let i=0;i<12;i++){
    const r = Math.floor(i/cols), c = i%cols;
    const x = startX + c*(w+gap), y = startY + r*(h+gap);
    if(matchState.cards[i].removed) continue;
    if(mx >= x && mx <= x+w && my >= y && my <= y+h){
      flipCard(i); break;
    }
  }
});

function flipCard(i){
  const card = matchState.cards[i];
  if(card.faceUp || card.removed) return;
  card.faceUp = true; matchState.flipped.push(card); drawMatch();
  if(matchState.flipped.length === 2){
    const [a,b] = matchState.flipped;
    if(a.obj === b.obj){
      // match
      a.removed = true; b.removed = true; matchState.removed += 2;
      matchState.flipped = [];
      coins += 3; saveState(); notify('+3 coins for a match!');
      drawMatch();
      if(matchState.removed === 12){ notify('All pairs found! +10 coins'); coins += 10; saveState(); drawMatch(); }
    } else {
      // flip back after short delay
      setTimeout(()=>{ a.faceUp = false; b.faceUp = false; matchState.flipped = []; drawMatch(); }, 700);
    }
  }
}

// -----------------------------------------------------------
// GAME: DRAW-A-PATH (car follows drawn path avoiding obstacles)
// -----------------------------------------------------------
let pathState = {drawing:false, path:[], car:{x:80,y:mainCanvas.height-100, r:14}, obstacles:[], running:false};
function initPath(){
  // generate a few obstacles on the field (rectangles)
  pathState.path = []; pathState.obstacles = [];
  const count = 6;
  for(let i=0;i<count;i++){
    const x = 200 + i*100 + Math.random()*80;
    const y = 120 + Math.random()*160;
    const w = 40 + Math.random()*60, h = 30 + Math.random()*40;
    pathState.obstacles.push({x,y,w,h});
  }
  drawPathScene();
}

function drawPathScene(){
  ctx.clearRect(0,0,mainCanvas.width, mainCanvas.height);
  ctx.fillStyle = '#fff7ff'; ctx.fillRect(0,0,mainCanvas.width, mainCanvas.height);
  // draw path lines
  if(pathState.path.length > 1){
    ctx.strokeStyle = '#ff9ab2'; ctx.lineWidth = 4; ctx.beginPath();
    ctx.moveTo(pathState.path[0].x, pathState.path[0].y);
    for(let i=1;i<pathState.path.length;i++) ctx.lineTo(pathState.path[i].x, pathState.path[i].y);
    ctx.stroke();
  }
  // draw obstacles
  ctx.fillStyle = '#7a1b5a'; pathState.obstacles.forEach(ob => ctx.fillRect(ob.x, ob.y, ob.w, ob.h));
  // draw car avatar
  drawPrincess(pathState.car.x, pathState.car.y, pathState.car.r*2);
  ctx.fillStyle='#5b3b51'; ctx.font='14px sans-serif'; ctx.fillText('Draw path for the car (draw ahead of it)', mainCanvas.width/2, 20);
}

mainCanvas.addEventListener('pointerdown', (e)=>{
  if(currentGame === 'path'){
    pathState.drawing = true; pathState.path = [];
    const rect = mainCanvas.getBoundingClientRect();
    const x = (e.clientX - rect.left) * (mainCanvas.width / rect.width);
    const y = (e.clientY - rect.top) * (mainCanvas.height / rect.height);
    pathState.path.push({x,y});
    drawPathScene();
  }
});
mainCanvas.addEventListener('pointermove', (e)=>{
  if(currentGame === 'path' && pathState.drawing){
    const rect = mainCanvas.getBoundingClientRect();
    const x = (e.clientX - rect.left) * (mainCanvas.width / rect.width);
    const y = (e.clientY - rect.top) * (mainCanvas.height / rect.height);
    pathState.path.push({x,y});
    if(pathState.path.length > 200) pathState.path.shift();
    drawPathScene();
  }
});
mainCanvas.addEventListener('pointerup', (e)=>{
  if(currentGame === 'path' && pathState.drawing){
    pathState.drawing = false;
    // start the car following the path
    if(pathState.path.length > 3){
      pathState.running = true; followPath();
    } else notify('Draw a longer path to start');
  }
});

function followPath(){
  if(!pathState.running || pathState.path.length === 0) return;
  // move car along path points
  const target = pathState.path.shift();
  if(!target){ // no more path
    pathState.running = false; // evaluate success if reached far right
    if(pathState.car.x > mainCanvas.width - 80) { coins += 5; saveState(); notify('Path complete! +5 coins'); } else notify('Path ended â€” try longer next time');
    return;
  }
  // move car smoothly toward target
  const dx = target.x - pathState.car.x, dy = target.y - pathState.car.y;
  pathState.car.x += dx * 0.12; pathState.car.y += dy * 0.12;
  // collision check with obstacles
  for(const ob of pathState.obstacles){
    if(pathState.car.x + pathState.car.r > ob.x && pathState.car.x - pathState.car.r < ob.x + ob.w &&
       pathState.car.y + pathState.car.r > ob.y && pathState.car.y - pathState.car.r < ob.y + ob.h){
      // collision
      if(hearts > 0){ hearts--; saveState(); notify('Heart used â€” car returned to start'); pathState.car.x = 80; pathState.car.y = mainCanvas.height - 100; pathState.running = false; return; }
      if(coins >= 15) coins = 5; else coins = 0; saveState(); updateHUD();
      pathState.car.x = 80; pathState.car.y = mainCanvas.height - 100; pathState.running = false; notify('Car hit obstacle â€” back to start');
      return;
    }
  }
  drawPathScene();
  requestAnimationFrame(followPath);
}

// -----------------------------------------------------------
// Game lifecycle: start/reset & helpers
// -----------------------------------------------------------
function prepareView(){
  // show/hide blockCanvas
  blockCanvas.style.display = currentGame === 'block' ? 'block' : 'none';
  clearMain();
  if(currentGame === 'block') drawGrid();
  if(currentGame === 'match') drawMatch();
  if(currentGame === 'path') drawPathScene();
}
prepareView();

function startCurrentGame(){
  if(!selected){ notify('Pick a princess first!'); return; }
  // countdown 3..2..1 then start
  let n=3; countdownEl.textContent = '';
  countdownEl.style.fontWeight = '700';
  const cd = setInterval(()=>{ countdownEl.textContent = n>0 ? n : ''; if(n===0){ clearInterval(cd); countdownEl.textContent=''; actuallyStart(); } n--;}, 650);
  function actuallyStart(){
    if(currentGame === 'flap'){ FLAP.running = true; flapReset(); flapLoop(); notify('Flap â€” go!'); }
    if(currentGame === 'block'){ // grid interactive immediately; just notify
      gridInit(); drawGrid(); notify('Block Blast â€” drag blocks into the grid!');
    }
    if(currentGame === 'runner'){
      runner.running = true; runnerReset(); runnerLoop(); notify('Runner â€” go!'); 
    }
    if(currentGame === 'match'){ initMatch(); notify('Match Game started'); }
    if(currentGame === 'path'){ initPath(); notify('Draw your path to start'); }
  }
}

function resetCurrentGame(){
  countdownEl.textContent = '';
  if(currentGame === 'flap'){ FLAP.running = false; flapReset(); }
  if(currentGame === 'block'){ // reset grid only
    for(let r=0;r<GRID_ROWS;r++) for(let c=0;c<GRID_COLS;c++) grid[r][c]=0;
    drawGrid(); notify('Block grid reset');
  }
  if(currentGame === 'runner'){ runner.running = false; runnerReset(); }
  if(currentGame === 'match'){ initMatch(); notify('Match reset'); }
  if(currentGame === 'path'){ pathState.running = false; initPath(); notify('Path reset'); }
}

// helper grid init
function gridInit(){ for(let r=0;r<GRID_ROWS;r++) for(let c=0;c<GRID_COLS;c++) grid[r][c]=0; drawGrid(); }

// small helper to ensure saves & HUD updates
function saveState(){ localStorage.setItem('arcade_coins', coins); localStorage.setItem('arcade_hearts', hearts); updateHUD(); }

// initial state setup
gridInit(); initMatch(); initPath(); flapReset(); runnerReset();

// small helper to update HUD when coins change
function applyHUD(){ updateHUD(); }

// re-draw loops for runner and flap started elsewhere already
// No alerts used; notifications via notify()

</script>
</body>
</html>
