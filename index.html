<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Princess Arcade â€” Functional Build</title>
<style>
  /* minimal, functional UI */
  :root{--accent:#ff5aa2;--bg:#fff0fb;--muted:#3b2b3b}
  html,body{height:100%;margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;background:var(--bg);-webkit-font-smoothing:antialiased}
  .wrap{max-width:1100px;margin:14px auto;padding:14px}
  header{display:flex;justify-content:space-between;align-items:center}
  h1{margin:0;color:var(--muted)}
  .top-controls{display:flex;gap:8px;align-items:center}
  .badge{background:#fff;padding:8px 12px;border-radius:10px;font-weight:700;box-shadow:0 6px 18px rgba(0,0,0,0.06)}
  nav{margin:10px 0}
  nav button{padding:8px 12px;margin-right:8px;border-radius:8px;border:none;background:var(--accent);color:#fff;cursor:pointer}
  .stage{background:#fff;padding:12px;border-radius:12px;box-shadow:0 8px 28px rgba(0,0,0,0.06)}
  .grid{display:flex;gap:12px}
  .left{flex:1}
  .right{width:320px}
  canvas{width:100%;height:360px;border-radius:8px;display:block;background:#fff}
  #drawCanvas{height:420px}
  .controls{margin-top:10px;display:flex;gap:8px;align-items:center}
  .btn{padding:8px 12px;border-radius:8px;border:none;background:var(--accent);color:#fff;cursor:pointer}
  .btn.ghost{background:#fff;border:1px solid #eee;color:#333}
  #notify{position:fixed;left:50%;transform:translateX(-50%);top:12px;background:#fff;padding:8px 12px;border-radius:10px;box-shadow:0 8px 28px rgba(0,0,0,0.12);display:none;z-index:999}
  /* selection modal */
  #selectModal{position:fixed;inset:0;background:rgba(0,0,0,0.5);display:flex;align-items:center;justify-content:center;z-index:900}
  #selectCard{background:#fff;padding:18px;border-radius:12px;width:92%;max-width:720px}
  .prin-list{display:flex;flex-wrap:wrap;gap:10px}
  .prin-card{flex:0 0 48%;background:#fafafa;padding:8px;border-radius:8px;cursor:pointer;border:2px solid transparent}
  .prin-card.selected{border-color:var(--accent)}
  .small{font-size:13px;color:#6b4a62}
  /* match board */
  #matchBoard{display:flex;flex-wrap:wrap;gap:8px;justify-content:center}
  .card{width:86px;height:100px;background:#fff;border-radius:8px;display:flex;align-items:center;justify-content:center;font-size:26px;cursor:pointer;border:2px solid #fde6f2}
  /* store & instructions */
  #storePanel,#instrPanel{display:none;padding:12px;background:#fff;border-radius:10px;box-shadow:0 8px 28px rgba(0,0,0,0.06)}
  @media (max-width:900px){ .prin-card{flex:0 0 100%} .right{width:100%} canvas{height:300px} #drawCanvas{height:360px} }
</style>
</head>
<body>
<div class="wrap">
  <header>
    <div>
      <h1>Princess Arcade â€” Functional Build</h1>
      <div class="small">Pick a princess, then choose a game. Coins & hearts persist.</div>
    </div>
    <div class="top-controls">
      <div class="badge">Coins: <span id="coins">0</span></div>
      <div class="badge">Hearts: <span id="hearts">0</span></div>
      <button id="openStore" class="btn">Store</button>
      <button id="openInstr" class="btn btn-ghost">Instructions</button>
    </div>
  </header>

  <nav>
    <button data-game="flappy" class="gameBtn">Flappy Princess</button>
    <button data-game="runner" class="gameBtn">Princess Runner</button>
    <button data-game="match" class="gameBtn">Match Game</button>
    <button data-game="path" class="gameBtn">Draw-a-Path (Endless)</button>
  </nav>

  <div class="stage grid">
    <div class="left">
      <div id="mainStage" class="stage">
        <!-- canvases / boards -->
        <canvas id="canvasMain"></canvas>
        <canvas id="drawCanvas" style="display:none"></canvas>
        <div id="matchBoard" style="display:none"></div>
      </div>

      <div class="controls">
        <div id="selectedInfo" class="small">No princess selected</div>
        <div style="flex:1"></div>
        <div id="countdown" class="small"></div>
        <button id="startBtn" class="btn">Start</button>
        <button id="resetBtn" class="btn btn-ghost">Reset</button>
      </div>
    </div>

    <div class="right">
      <div class="stage">
        <h3 style="margin:6px 0">Princess Selection</h3>
        <div class="small">Pick a princess (name + object). Selection applies to all games.</div>
        <div style="height:10px"></div>
        <button id="choosePrincess" class="btn">Choose/Change Princess</button>
        <div style="height:12px"></div>

        <h4 style="margin:6px 0">Object Control</h4>
        <div class="small">Use this button (or SPACE) in Flappy / Runner</div>
        <div style="height:8px"></div>
        <div id="objectArea"></div>

        <div style="height:12px"></div>
        <h4 style="margin:6px 0">Quick Notes</h4>
        <div class="small">Hearts prevent a full coin loss and return you to start. Earn coins across games.</div>
      </div>
    </div>
  </div>

  <div id="storePanel" class="stage" style="margin-top:12px">
    <h3>Store</h3>
    <div>Hearts cost <strong>30</strong> coins each.</div>
    <div style="height:10px"></div>
    <button id="buyHeartBtn" class="btn">Buy Heart (30)</button>
    <div style="height:10px"></div>
    <button id="closeStore" class="btn btn-ghost">Close Store</button>
  </div>

  <div id="instrPanel" class="stage" style="margin-top:12px">
    <h3>Instructions</h3>
    <div class="small" style="line-height:1.4">
      <strong>Flappy:</strong> SPACE or the object button performs an upward dash. Avoid obstacles that show the same object.<br>
      <strong>Runner:</strong> After the 3-2-1 countdown, tap/SPACE to jump. Fair hitbox, reset to start on hit.<br>
      <strong>Match:</strong> Flip two cards â€” match pairs to remove them, earn coins.<br>
      <strong>Path:</strong> Draw ahead of the moving world. The world scrolls forward continuously; draw a path ahead to avoid obstacles. The game gets harder as obstacles appear further.
    </div>
    <div style="height:10px"></div>
    <button id="closeInstrPanel" class="btn btn-ghost">Close</button>
  </div>

</div>

<!-- princess selection modal -->
<div id="selectModal" style="display:none">
  <div id="selectCard">
    <h3>Select Princess</h3>
    <div class="small">Each princess has a unique object you use to dodge.</div>
    <div style="height:10px"></div>
    <div class="prin-list" id="prinList"></div>
    <div style="height:12px"></div>
    <div style="text-align:right">
      <button id="confirmPrincess" class="btn">Confirm</button>
    </div>
  </div>
</div>

<div id="notify"></div>

<script>
/* Fully functional arcade single-file
   - Flappy (object obstacles; space or object button to dash)
   - Runner (countdown; jump; fair collisions)
   - Match (12 cards)
   - Path (endless scroll; draw ahead)
   - Shop (buy hearts)
   - Princess selection
   - Persistent coins/hearts in localStorage
*/

// -------------------- Persisted state & HUD --------------------
let coins = Number(localStorage.getItem('pa_coins') || 0);
let hearts = Number(localStorage.getItem('pa_hearts') || 0);
const coinsEl = document.getElementById('coins');
const heartsEl = document.getElementById('hearts');
function saveState(){ localStorage.setItem('pa_coins', coins); localStorage.setItem('pa_hearts', hearts); updateHUD(); }
function updateHUD(){ coinsEl.textContent = coins; heartsEl.textContent = hearts; }
updateHUD();

function notify(msg, time=1600){
  const n = document.getElementById('notify');
  n.textContent = msg; n.style.display='block';
  clearTimeout(n._t); n._t = setTimeout(()=> n.style.display='none', time);
}

// -------------------- Princess data & selection --------------------
const PRINCESSES = [
  {name:'Ariel', object:'seashell', color:'#ff7fbf'},
  {name:'Elsa', object:'snowflake', color:'#cfe7ff'},
  {name:'Moana', object:'wave', color:'#9fd4ff'},
  {name:'Mulan', object:'sword', color:'#ffd6e9'},
  {name:'Cinderella', object:'slipper', color:'#cfe0ff'},
  {name:'Rapunzel', object:'lizard', color:'#f7d06a'},
  {name:'Tiana', object:'frog', color:'#9be9b6'},
  {name:'Belle', object:'book', color:'#ffd07a'}
];
let selectedPrincess = null;

// populate selection modal
const prinListEl = document.getElementById('prinList');
PRINCESSES.forEach((p, idx)=>{
  const card = document.createElement('div');
  card.className = 'prin-card';
  card.innerHTML = `<div style="font-weight:700">${p.name}</div><div class="small">object: ${p.object}</div>`;
  card.addEventListener('click', ()=> {
    document.querySelectorAll('.prin-card').forEach(x=>x.classList.remove('selected'));
    card.classList.add('selected');
    card.dataset.idx = idx;
  });
  prinListEl.appendChild(card);
});

document.getElementById('choosePrincess').addEventListener('click', ()=> {
  document.getElementById('selectModal').style.display = 'flex';
});
document.getElementById('confirmPrincess').addEventListener('click', ()=> {
  const sel = document.querySelector('.prin-card.selected');
  if(!sel){ notify('Please pick a princess'); return; }
  const idx = Array.from(prinListEl.children).indexOf(sel);
  selectedPrincess = PRINCESSES[idx];
  document.getElementById('selectModal').style.display='none';
  document.getElementById('selectedInfo').textContent = `${selectedPrincess.name} â€” object: ${selectedPrincess.object}`;
  setupObjectControl();
  notify(`${selectedPrincess.name} selected`);
});

// -------------------- UI events: store / instructions --------------------
document.getElementById('openStore').addEventListener('click', ()=> {
  document.getElementById('storePanel').style.display = 'block';
  document.getElementById('instrPanel').style.display = 'none';
});
document.getElementById('closeStore').addEventListener('click', ()=> document.getElementById('storePanel').style.display='none');
document.getElementById('openInstr').addEventListener('click', ()=> {
  document.getElementById('instrPanel').style.display = 'block';
  document.getElementById('storePanel').style.display = 'none';
});
document.getElementById('closeInstrPanel').addEventListener('click', ()=> document.getElementById('instrPanel').style.display='none');
document.getElementById('buyHeartBtn').addEventListener('click', ()=> {
  if(coins >= 30){ coins -= 30; hearts++; saveState(); notify('Heart purchased'); } else notify('Need 30 coins');
});

// -------------------- Game switching --------------------
let currentGame = 'flappy';
const gameButtons = document.querySelectorAll('.gameBtn');
gameButtons.forEach(btn=>{
  btn.addEventListener('click', ()=> {
    currentGame = btn.dataset.game;
    showGameView(currentGame);
  });
});

const canvasMain = document.getElementById('canvasMain');
const ctx = canvasMain.getContext('2d');
const drawCanvas = document.getElementById('drawCanvas');
const dctx = drawCanvas.getContext('2d');
const matchBoard = document.getElementById('matchBoard');

function showGameView(game){
  // hide all
  canvasMain.style.display = 'none';
  drawCanvas.style.display = 'none';
  matchBoard.style.display = 'none';
  document.getElementById('storePanel').style.display = 'none';
  document.getElementById('instrPanel').style.display = 'none';
  // clear countdown
  document.getElementById('countdown').textContent = '';
  // show relevant view
  if(game === 'path') { drawCanvas.style.display = 'block'; } else if(game === 'match') { matchBoard.style.display = 'flex'; } else { canvasMain.style.display = 'block'; }
  resetCurrentGame();
}
showGameView('flappy');

// adjust canvas size to stage
function fitCanvases(){
  const mainStage = document.getElementById('mainStage');
  const rect = mainStage.getBoundingClientRect();
  canvasMain.width = rect.width;
  canvasMain.height = Math.max(260, rect.height - 40);
  drawCanvas.width = rect.width;
  drawCanvas.height = Math.max(320, rect.height + 40);
}
window.addEventListener('resize', ()=> { fitCanvases(); drawCurrentView(); });
fitCanvases();

// -------------------- Shared helpers --------------------
function resetCurrentGame(){
  // stop all loops
  stopAllLoops();
  // reinitialize the game state for the current game
  if(currentGame === 'flappy') initFlappy();
  if(currentGame === 'runner') initRunner();
  if(currentGame === 'match') initMatch();
  if(currentGame === 'path') initPath();
}
document.getElementById('startBtn').addEventListener('click', ()=> startWithCountdown());
document.getElementById('resetBtn').addEventListener('click', ()=> { resetCurrentGame(); notify('Reset'); });

// prevent multiple loops
let loopHandles = [];
function stopAllLoops(){ loopHandles.forEach(h => h.stop && h.stop()); loopHandles = []; }

// -------------------- OBJECT CONTROL (button) --------------------
function setupObjectControl(){
  const area = document.getElementById('objectArea');
  area.innerHTML = '';
  if(!selectedPrincess) return;
  const btn = document.createElement('button');
  btn.className = 'btn';
  btn.textContent = selectedPrincess.object;
  btn.addEventListener('click', ()=> {
    // use object action depending on game
    if(currentGame === 'flappy' && flappyState.running) flappyDash();
    if(currentGame === 'runner' && runnerState.running) runnerJump();
    // path game doesn't use object
  });
  area.appendChild(btn);
}

// initial call to object control if princess pre-selected
setupObjectControl();

// -------------------- GAME: FLAPPY --------------------
let flappyState = null;
function initFlappy(){
  flappyState = {
    running:false,
    princess:{x: Math.max(100, canvasMain.width*0.12), y: canvasMain.height/2, vy:0, size:40},
    gravity:0.9, flapPower:-10, dashPower:-16,
    obstacles:[], frames:0, score:0, spawnRate:90
  };
  drawFlap(); // initial draw
}
function drawFlap(){
  ctx.clearRect(0,0,canvasMain.width, canvasMain.height);
  // background
  ctx.fillStyle = '#fff7ff'; ctx.fillRect(0,0,canvasMain.width, canvasMain.height);
  // ground
  ctx.fillStyle = '#fff'; ctx.fillRect(0, canvasMain.height-60, canvasMain.width, 60);
  // princess
  const p = flappyState.princess;
  ctx.fillStyle = selectedPrincess ? selectedPrincess.color : '#ddd';
  ctx.beginPath(); ctx.arc(p.x, p.y, p.size/2, 0, Math.PI*2); ctx.fill();
  ctx.fillStyle = '#fff'; ctx.font='12px sans-serif'; ctx.textAlign='center'; ctx.fillText(selectedPrincess ? selectedPrincess.name.slice(0,2).toUpperCase() : 'PR', p.x, p.y+4);
  // obstacles
  flappyState.obstacles.forEach(ob=>{
    // draw object icon as text (simple and clear)
    ctx.font = '26px serif';
    ctx.fillStyle = '#6b2b4b';
    const symbol = objectToSymbol(selectedPrincess ? selectedPrincess.object : 'obj');
    ctx.fillText(symbol, ob.x, ob.y);
  });
  // HUD
  ctx.fillStyle = '#333'; ctx.font='14px sans-serif'; ctx.fillText(`Score: ${flappyState.score}`, 12, 18);
}
function objectToSymbol(obj){
  // simple mapping emoji-like (fallback to a char if unavailable)
  const map = {
    seashell: 'ðŸš', snowflake: 'â„ï¸', wave: 'ðŸŒŠ', sword: 'ðŸ—¡ï¸',
    slipper: 'ðŸ‘ ', lizard: 'ðŸ¦Ž', frog: 'ðŸ¸', book: 'ðŸ“–'
  };
  return map[obj] || 'â˜…';
}
function spawnFlappyObstacle(){
  const y = 60 + Math.random() * (canvasMain.height - 140);
  flappyState.obstacles.push({x: canvasMain.width + 40, y: y});
}
function flappyUpdate(){
  if(!flappyState.running) return;
  flappyState.frames++;
  // spawn
  const rate = Math.max(40, flappyState.spawnRate - Math.floor(flappyState.score/6));
  if(flappyState.frames % rate === 0) spawnFlappyObstacle();
  // physics
  flappyState.princess.vy += flappyState.gravity * 0.6;
  flappyState.princess.y += flappyState.princess.vy;
  // constraints
  if(flappyState.princess.y > canvasMain.height - 60) flappyState.princess.y = canvasMain.height - 60, flappyState.princess.vy = 0;
  if(flappyState.princess.y < 20) flappyState.princess.y = 20, flappyState.princess.vy = 0;
  // move obstacles, score when they pass
  for(let i=flappyState.obstacles.length-1;i>=0;i--){
    const o = flappyState.obstacles[i];
    o.x -= 3 + Math.min(3, flappyState.score/80);
    if(o.x < -20) { flappyState.obstacles.splice(i,1); flappyState.score++; coins++; saveState(); updateHUD(); }
  }
  // collision: tight hitbox for fairness
  const p = flappyState.princess;
  const px = p.x - p.size*0.3, py = p.y - p.size*0.3, pw = p.size*0.6, ph = p.size*0.6;
  for(const o of flappyState.obstacles){
    const ox = o.x - 18, oy = o.y - 18, ow = 36, oh = 36;
    if(px < ox + ow && px + pw > ox && py < oy + oh && py + ph > oy){
      // collision occurred
      if(hearts > 0){ hearts--; saveState(); flappyState.princess.y = canvasMain.height/2; flappyState.obstacles=[]; notify('Heart used â€” returned to start'); return; }
      // coin keep rule
      if(coins >= 15) coins = 5; else coins = 0;
      saveState(); updateHUD();
      flappyState.running = false;
      flappyState.princess.y = canvasMain.height/2;
      flappyState.obstacles = [];
      notify('Hit â€” back to start');
      return;
    }
  }
}
function flappyLoop(){
  if(!flappyState.running) return;
  flappyUpdate(); drawFlap();
  const h = requestAnimationFrame(flappyLoop);
  loopHandles.push

```


